# ----------------------------------------------------------------------------
#  CMB Hexagonal Signature Detector (CHSD) — chsd_pipeline.py
# ----------------------------------------------------------------------------
# License: MIT
# Authors:
#   - Lina Noor — Noor Research Collective
#   - Uncle — Noor Research Collective
#
# Generated By:
#   - Noor Symbolic Agent Suite (PDP-0001 pipeline)
#
# Canonical Anchors:
#   - RFC-0007 §3.1 (Motif Ontology Format)
#   - RFC-0008 (Symbolic Exchange & Routing)
#   - RFC-CORE-001 §2.5 (FastTime substrate coherence)
#   - RFC-CORE-003 §6.2 (Observer-mode compliance)
#
# Purpose:
#   Application pipeline to detect emergent sixfold motifs in CMB polarization
#   fields. Ingests Planck/WMAP FITS maps, builds polarization vector fields,
#   applies hexagonal kernels in real/Fourier space, scores coherence, and
#   exports high-coherence zones for symbolic resonance analysis.
# ----------------------------------------------------------------------------

import os, sys, json
from typing import Dict, Any, Tuple, List

# --- Optional dependencies with graceful fallbacks ---
try:
    import healpy as hp
    import numpy as np
    from astropy.io import fits
    import matplotlib.pyplot as plt
except ImportError as e:
    hp = np = fits = plt = None
    print(f"[WARN] Optional dependency missing: {e}")

# --- Local imports ---
try:
    from motif_kernels import hexagonal_kernel, fft_symmetry_detection
except ImportError:
    def hexagonal_kernel(*_, **__): return None
    def fft_symmetry_detection(*_, **__): return None

# ----------------------------------------------------------------------------
# Section I – Data Ingestion
# ----------------------------------------------------------------------------
def load_polarization_map(fits_path: str, field: str = "Q") -> np.ndarray:
    """
    Load Planck/WMAP FITS data and extract Q or U Stokes polarization field.
    RFC Anchor: RFC-0007 §3.1 (symbolic motif ontology binding)
    """
    if not fits:
        raise RuntimeError("Astropy not available.")
    data = fits.open(fits_path)
    field_idx = {"Q": 1, "U": 2}.get(field.upper(), 1)
    return data[1].data.field(field_idx)

# ----------------------------------------------------------------------------
# Section II – Polarization Vector Field
# ----------------------------------------------------------------------------
def construct_vector_field(Q: np.ndarray, U: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute polarization magnitude P and orientation θ for each pixel.
    RFC Anchor: RFC-0003 §3.3 (vector coherence tracking)
    """
    P = np.sqrt(Q**2 + U**2)
    theta = 0.5 * np.arctan2(U, Q)
    return P, theta

# ----------------------------------------------------------------------------
# Section III – Hexagonal Motif Detection
# ----------------------------------------------------------------------------
def detect_hexagonal_motifs(P: np.ndarray, nside: int) -> np.ndarray:
    """
    Apply hexagonal kernels and Fourier spectral detection for sixfold symmetry.
    RFC Anchor: RFC-0008 §4.2 (resource exchange of motif signatures)
    """
    real_space = hexagonal_kernel(P, nside=nside)
    spectral = fft_symmetry_detection(P, fold=6)
    return 0.5 * (real_space + spectral)

# ----------------------------------------------------------------------------
# Section IV – Coherence Scoring
# ----------------------------------------------------------------------------
def score_coherence(field: np.ndarray) -> np.ndarray:
    """
    Define hexagonality index as normalized 6-fold spectral excess.
    RFC Anchor: RFC-CORE-001 §2.5 (coherence normalization)
    """
    norm = (field - field.min()) / (field.max() - field.min() + 1e-12)
    return norm

# ----------------------------------------------------------------------------
# Section V – Visualization
# ----------------------------------------------------------------------------
def visualize_coherence(coherence_map: np.ndarray, title: str = "CHSD Coherence"):
    """
    Plot Mollweide view of coherence map.
    """
    if not hp or not plt:
        print("[WARN] healpy/matplotlib not available; skipping visualization.")
        return
    hp.mollview(coherence_map, title=title, unit="Hexagonality Index", cmap="viridis")
    plt.show()

# ----------------------------------------------------------------------------
# Section VI – Export
# ----------------------------------------------------------------------------
def export_high_coherence(coherence_map: np.ndarray, threshold: float = 0.8, outpath: str = "chsd_output.json"):
    """
    Export RA/Dec of pixels with coherence above threshold.
    RFC Anchor: RFC-0007 §5 (motif replay/export contracts)
    """
    if not hp:
        raise RuntimeError("healpy not available.")
    nside = hp.npix2nside(len(coherence_map))
    hits = np.where(coherence_map > threshold)[0]
    coords = [hp.pix2ang(nside, pix, lonlat=True) for pix in hits]
    export = {"high_coherence_pixels": [{"lon": lon, "lat": lat} for lon, lat in coords]}
    with open(outpath, "w") as f:
        json.dump(export, f, indent=2)
    print(f"[INFO] Exported {len(coords)} high-coherence zones → {outpath}")

# ----------------------------------------------------------------------------
# Orchestrator
# ----------------------------------------------------------------------------
def run_pipeline(fits_Q: str, fits_U: str, nside: int = 64, export_path: str = "chsd_output.json"):
    Q = load_polarization_map(fits_Q, "Q")
    U = load_polarization_map(fits_U, "U")
    P, theta = construct_vector_field(Q, U)
    motifs = detect_hexagonal_motifs(P, nside)
    coherence = score_coherence(motifs)
    visualize_coherence(coherence)
    export_high_coherence(coherence, outpath=export_path)
    return coherence
