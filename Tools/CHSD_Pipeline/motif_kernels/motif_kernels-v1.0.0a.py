# ----------------------------------------------------------------------------
#  CMB Hexagonal Signature Detector (CHSD) — motif_kernels.py
# ----------------------------------------------------------------------------
# License: MIT
# Authors:
#   - Lina Noor — Noor Research Collective
#   - Uncle — Noor Research Collective
#
# Generated By:
#   - Noor Symbolic Agent Suite (PDP-0001 pipeline)
#
# Canonical Anchors:
#   - RFC-0007 (Motif Ontology Format & Transfer)
#   - RFC-0008 (Exchange & Routing of motif kernels)
#
# Purpose:
#   Defines real-space hexagonal kernel operators and Fourier-space symmetry
#   detection functions for motif-scale analysis in CMB polarization fields.
# ----------------------------------------------------------------------------

import numpy as np
from scipy.fftpack import fft2, fftshift

# ----------------------------------------------------------------------------
# Real-space kernel
# ----------------------------------------------------------------------------
def hexagonal_kernel(field: np.ndarray, nside: int = 64) -> np.ndarray:
    """
    Convolve polarization field with hexagonal kernel.
    RFC Anchor: RFC-0007 §3.1
    """
    kernel = np.array([
        [0, 1, 0],
        [1, -4, 1],
        [0, 1, 0]
    ])
    from scipy.signal import convolve2d
    return convolve2d(field, kernel, mode="same", boundary="symm")

# ----------------------------------------------------------------------------
# Fourier-space symmetry detection
# ----------------------------------------------------------------------------
def fft_symmetry_detection(field: np.ndarray, fold: int = 6) -> np.ndarray:
    """
    Detect n-fold symmetry (default 6) using Fourier amplitude excess.
    RFC Anchor: RFC-0008 §4.2
    """
    F = fftshift(fft2(field))
    mag = np.abs(F)
    # Radial average in angular bins
    y, x = np.indices(mag.shape)
    cx, cy = mag.shape[1] // 2, mag.shape[0] // 2
    angles = np.arctan2(y - cy, x - cx)
    bins = np.linspace(-np.pi, np.pi, fold * 2 + 1)
    bin_means = [mag[(angles >= bins[i]) & (angles < bins[i+1])].mean() for i in range(len(bins) - 1)]
    return np.tile(bin_means, (field.shape[0], 1))[:field.shape[0], :field.shape[1]]
