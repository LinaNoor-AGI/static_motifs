# -------------------------------------------------------------------------
#
# NOOR SYMBOLIC-AI-DRIVEN ARTIFACT
#
# This code was generated by Google Gemini Pro 1.5, acting as a Noor
# Symbolic Agent. It reflects the layered constraints and semantic intent
# of the provided RFC/RFC-CORE and Application Specification documents.
#
# Generation Specification:
#   _symbolic_id: cmb.hexagonal.signature.detector
#   _version: v1.0.1
#
# RFC/RFC-CORE Compliance:
#   - RFC-0007: Output is structured for motif ontology compatibility.
#   - RFC-CORE-001: Aligns with principles of symbolic state detection.
# -------------------------------------------------------------------------

"""
motif_kernels.py

Hexagonal kernel definitions and Fourier-space motif operators for the CMB
Hexagonal Signature Detector (CHSD).

This module provides the core functions for identifying sixfold (hexagonal)
symmetry in 2D data patches, intended for use on polarization fields of the
Cosmic Microwave Background.
"""

__version__ = "1.0.1"
__author__ = "Lina Noor & Uncle (via Noor Symbolic Agent)"
__license__ = "MIT"
__copyright__ = "Copyright 2025, Noor Research Collective"


import numpy as np
from scipy import ndimage
from typing import Tuple

def create_hexagonal_kernel(size: int, sigma: float = 0.1, angle_offset: float = 0.0) -> np.ndarray:
    """
    Creates a 2D kernel with a sixfold (hexagonal) pattern of Gaussians.

    This kernel can be used for real-space convolution to find hexagonal
    patterns, though the primary method in the pipeline uses FFT.

    Args:
        size (int): The width and height of the kernel grid (e.g., 32 for 32x32).
        sigma (float): The standard deviation of the Gaussian spots, as a
                       fraction of the kernel size.
        angle_offset (float): An initial rotation for the hexagonal pattern in degrees.

    Returns:
        np.ndarray: A 2D numpy array representing the hexagonal kernel.
    """
    if size % 2 == 0:
        size += 1 # Ensure odd size for a central pixel

    radius = size // 2
    x = np.linspace(-1, 1, size)
    xx, yy = np.meshgrid(x, x)
    kernel = np.zeros((size, size))
    
    # Radius of the hexagon vertices from the center
    hex_radius = 0.5

    for i in range(6):
        angle = np.deg2rad(60 * i + angle_offset)
        cx = hex_radius * np.cos(angle)
        cy = hex_radius * np.sin(angle)
        
        # Add a Gaussian blob at each vertex of the hexagon
        g = np.exp(-((xx - cx)**2 + (yy - cy)**2) / (2 * sigma**2))
        kernel += g
        
    # Normalize the kernel
    return kernel / np.sum(kernel)

def calculate_fft_symmetry(patch: np.ndarray, n_folds: int = 6) -> float:
    """
    Calculates the degree of N-fold rotational symmetry in a 2D patch
    using its 2D Fast Fourier Transform (FFT).

    This function quantifies the "hexagonality index" as per the application
    specification by measuring the excess power in 6-fold symmetric directions
    within the frequency domain.

    Args:
        patch (np.ndarray): A 2D numpy array representing a data patch.
        n_folds (int): The number of folds for symmetry detection (e.g., 6 for hexagonal).

    Returns:
        float: A coherence score from 0.0 to 1.0 indicating the strength of
               the N-fold symmetry. A higher value means stronger symmetry.
    """
    if patch.shape[0] < 2 or patch.shape[1] < 2:
        return 0.0
    
    # 1. Compute the 2D FFT and shift the zero-frequency component to the center
    fft_patch = np.fft.fft2(patch)
    fft_shifted = np.fft.fftshift(fft_patch)
    magnitude_spectrum = np.abs(fft_shifted)
    
    # To avoid division by zero
    if np.sum(magnitude_spectrum) == 0:
        return 0.0

    # 2. Correlate the magnitude spectrum with rotated versions of itself
    angle_step = 360.0 / n_folds
    correlations = []
    
    for i in range(1, n_folds):
        angle = i * angle_step
        # Rotate the spectrum. `reshape=False` prevents the array size from changing.
        rotated_spectrum = ndimage.rotate(
            magnitude_spectrum, angle, reshape=False, order=1, mode='constant', cval=0.0
        )
        
        # Calculate the correlation coefficient between the original and rotated spectrum
        # Using a simple normalized dot product as a correlation measure
        numerator = np.sum(magnitude_spectrum * rotated_spectrum)
        denominator = np.sqrt(np.sum(magnitude_spectrum**2) * np.sum(rotated_spectrum**2))
        
        if denominator > 0:
            correlation = numerator / denominator
            correlations.append(correlation)

    # 3. The symmetry score is the average of these correlations.
    if not correlations:
        return 0.0
        
    return float(np.mean(correlations))

# --- End of file ---