# -*- coding: utf-8 -*-
#
# MIT License
#
# Copyright (c) 2024 Lina Noor, Uncle, and the Noor Research Collective
#
# Generated by: Google Gemini 1.5 Pro (via user prompt)
# Generation Date: 2024-05-24
#
# This script is part of the CMB Hexagonal Signature Detector (CHSD) application.
# It provides the core functions for detecting 6-fold (hexagonal) symmetry
# in 2D data patches using Fourier-space analysis, as specified in
# CHSD_AppSpec.JSON (Spec-ID: III).

"""
motif_kernels.py: Core algorithms for hexagonal motif detection.

This module contains the low-level functions for analyzing 2D patches of
CMB polarization data to find evidence of hexagonal symmetry. The primary
method uses a 2D Fast Fourier Transform (FFT) to identify a 6-fold
spectral excess, which serves as a coherence score for the motif.
"""

import numpy as np
from scipy.interpolate import griddata

__version__ = "1.0.0b"
_SCHEMA_VERSION = "2025-Q4-canonical-header-v1"


def detect_symmetry_fft(patch: np.ndarray, num_angular_bins: int = 360) -> float:
    """
    Detects 6-fold symmetry in a 2D patch and computes a coherence score.

    This function follows the "6-fold spectral excess" principle. It transforms
    the patch into Fourier space, analyzes the angular power distribution, and
    measures the strength of the 6th harmonic, which corresponds to hexagonal
    symmetry.

    Args:
        patch (np.ndarray): A 2D numpy array representing a local region of
                            the sky (e.g., polarization magnitude).
        num_angular_bins (int): The number of bins to use for the angular
                                power spectrum.

    Returns:
        float: The hexagonality coherence score, ranging from 0.0 (no detected
               6-fold symmetry) to 1.0 (strong 6-fold symmetry). Returns 0.0
               if the patch is invalid.
    """
    if patch is None or patch.size == 0 or np.all(patch == patch[0, 0]):
        return 0.0

    # 1. Compute 2D FFT and shift the zero-frequency component to the center.
    f_transform = np.fft.fft2(patch)
    f_transform_shifted = np.fft.fftshift(f_transform)
    power_spectrum = np.abs(f_transform_shifted) ** 2

    # 2. Convert to polar coordinates to analyze angular distribution.
    center_y, center_x = np.array(power_spectrum.shape) / 2
    y, x = np.indices(power_spectrum.shape)
    radius = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
    angle = np.arctan2(y - center_y, x - center_x)

    # 3. Create an angular power spectrum by summing power along radial lines.
    # We ignore the very center (DC component) and edges to avoid artifacts.
    r_min = 0.1 * np.min(power_spectrum.shape) / 2
    r_max = 0.9 * np.min(power_spectrum.shape) / 2
    
    valid_indices = (radius > r_min) & (radius < r_max)
    
    if not np.any(valid_indices):
        return 0.0
        
    angles_rad = angle[valid_indices]
    powers = power_spectrum[valid_indices]

    # Bin the powers by angle
    angular_bins = np.linspace(-np.pi, np.pi, num_angular_bins + 1)
    bin_indices = np.digitize(angles_rad, angular_bins)
    
    angular_power = np.zeros(num_angular_bins)
    for i in range(1, num_angular_bins + 1):
        if np.any(bin_indices == i):
            angular_power[i - 1] = np.mean(powers[bin_indices == i])

    # 4. Compute the 1D FFT of the angular power spectrum to find harmonics.
    angular_fft = np.fft.fft(angular_power)
    angular_fft_power = np.abs(angular_fft)

    # The 6th component corresponds to 6-fold symmetry.
    if len(angular_fft_power) < 7:
        return 0.0
        
    hexagonal_power = angular_fft_power[6]

    # 5. Calculate coherence score as the "spectral excess" of the 6th harmonic.
    # We compare it to the mean power of other low-frequency harmonics (e.g., 2-12, excluding 6).
    other_harmonics_indices = list(range(2, 13))
    other_harmonics_indices.remove(6)
    
    if not other_harmonics_indices or len(angular_fft_power) <= max(other_harmonics_indices):
        return 0.0
        
    mean_other_power = np.mean(angular_fft_power[other_harmonics_indices])

    if mean_other_power < 1e-9:  # Avoid division by zero for flat spectra
        return 0.0

    coherence_score = hexagonal_power / (hexagonal_power + mean_other_power)

    return float(np.nan_to_num(coherence_score))

# --- End of file: motif_kernels.py ---